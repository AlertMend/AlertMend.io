import { BlogLayout } from "@/components/blog-layout";
import Thumbnail from "./thumbnail.jpeg";

export const blog = {
  author: { name: "Arvind Rajpurohit", src: "/img/avatar1.png" },
  date: "2025-08-1",
  title: "Graceful Shutdown in Kubernetes: Ensuring Safe Pod Termination",
  description:
    "Learn how to gracefully shut down Kubernetes Pods to prevent broken connections, dropped tasks, and race conditions during termination.",
  image:
    "/img/blogs/Graceful Shutdown in Kubernetes.png",
};

export const metadata = {
  title: blog.title,
  description: blog.description,
    keywords:
    'Kubernetes graceful shutdown, Kubernetes pod termination, SIGTERM in Kubernetes, Kubernetes preStop hook, terminationGracePeriodSeconds Kubernetes, Kubernetes rolling updates graceful shutdown, Kubernetes long running tasks, Kubernetes shutdown best practices, Kubernetes pod lifecycle, prevent traffic to terminating pods, Kubernetes SIGKILL handling, Kubernetes connection draining, Kubernetes readiness probe termination, safe pod shutdown Kubernetes, Kubernetes rainbow deployment strategy',
  openGraph: {
    images: [blog.image],
  },
   twitter: {
    card: 'summary_large_image',
    title: blog.title,
    description: blog.description,
    images: [blog.image],
  },
  alternates: {
    canonical: 'https://www.alertmend.io/blogs/Graceful-Shutdown-in-Kubernetes',
  },
};

export default (props) => <BlogLayout blog={blog} {...props} />;


---

## Why Graceful Shutdown Matters

Kubernetes Pods are dynamic by nature — created and destroyed frequently during rolling updates, scaling, node failures, and more.

But what happens if a Pod is serving live traffic or handling a long-running task and is abruptly terminated?

Without a graceful shutdown strategy, users may face:

-  Interrupted HTTP or WebSocket connections  
-  Partially completed jobs  
-  Metrics loss or corrupted data  
-  Increased error rates

---

## What Happens When a Pod is Created?

<div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '80vh' }}>
  <img
    src="/img/blogs/Pod Creation Lifecycle.png"
    alt="Pod Creation Lifecycle"
    style={{ width: '100%', height: '500px', objectFit: 'contain', borderRadius: '1px' }}
  />
</div>

The creation process involves:
1. Submitting to the Kubernetes API
2. Scheduling via the Scheduler
3. Kubelet creation via CRI, CNI, and CSI
4. IP assignment and readiness probe passing

Once the Pod is ready, it becomes an endpoint used by services like:

- kube-proxy  
- Ingress  
- CoreDNS  
- Prometheus  
- Service Mesh

---

## What Happens When a Pod is Deleted?

<div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '80vh' }}>
  <img
    src="/img/blogs/Pod Termination Flow.png"
    alt="Pod Termination Flow"
    style={{ width: '100%', height: '500px', objectFit: 'contain', borderRadius: '1px' }}
  />
</div>

Steps:
- Pod marked `Terminating` in etcd
- IP removed from Endpoint objects
- Notifies all components (kube-proxy, Ingress, etc.)
- Sends `SIGTERM` → waits → `SIGKILL` if needed

This can lead to **race conditions** if routing hasn’t updated yet.

---

## Graceful Shutdown Strategies

### 1. Catch SIGTERM in Your App

Use this time to finish requests and clean up resources.

---

### 2. Use a `preStop` Hook

Adds a buffer before shutdown begins  
Included in the total `terminationGracePeriodSeconds`

---

### 3. Set `terminationGracePeriodSeconds`

Gives more time for cleanup before the Pod is forcefully killed.

---

## Graceful Shutdown During Rolling Updates

<div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '80vh' }}>
  <img
    src="/img/blogs/Rolling Update Lifecycle.png"
    alt="Rolling Update Lifecycle"
    style={{ width: '100%', height: '500px', objectFit: 'contain', borderRadius: '1px' }}
  />
</div>

When deploying new versions:

- New Pods become ready in seconds
- Old Pods might take time to terminate
- You may temporarily have **double** the Pods running

Optimize shutdown to avoid resource bloat and scaling spikes.

---

## Long-Lived Connections or Tasks

Examples:
- WebSocket APIs  
- Video processing jobs  
- Real-time streaming

Don't kill them early — let them finish.

### Use Rainbow Deployments:

<div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '80vh' }}>
  <img
    src="/img/blogs/Rainbow Deployment Strategy.png"
    alt="Rainbow Deployment Strategy"
    style={{ width: '100%', height: '500px', objectFit: 'contain', borderRadius: '1px' }}
  />
</div>

- Create new Deployment
- Let old one continue
- Manually delete or scale to 0
- Use KEDA for auto-scaling

---

## Summary Table

| **Problem**                     | **Solution**                           |
|:--------------------------------|:---------------------------------------|
| Traffic sent to terminated Pods | Handle SIGTERM + delay shutdown        |
| Dropped DB/socket connections   | Add `preStop` + graceful termination   |
| Autoscaler over-scaling         | Optimize shutdown time                 |
| Metrics lost from old Pods      | Finish early and avoid delay           |
| Long tasks interrupted          | Use Rainbow Deployments                |

---

## Final Tips

- Log shutdown events (SIGTERM, preStop hook)
- Keep shutdown within 30 seconds unless necessary
- Avoid long termination times in high-scale environments
- Use readiness probes effectively